//---------------------------------------------------------------------------------------------
// Credits to Momentum Mod for this code and specifically xen-000
//---------------------------------------------------------------------------------------------


#ifdef _WIN32
    #pragma once
#endif
#include <cbase.h>

// You probably do not need this
// #define dbging yep

#if defined (BIN_PATCHES) && defined(ENGINE_DETOURS)
#include <engine_hacks/bin_patch.h>
#include <engine_hacks/engine_detours.h>
CEngineDetours* gCEngineDetours = nullptr;

#ifdef dbging
    #define goodcolor   Color(90, 240, 90, 255) // green
    #define okcolor     Color(246, 190, 0, 255) // yellow
#endif

CBinary g_CBinary;


// This is needed so that CAutoGameSystem knows that we're using it, apparently
CBinary::CBinary() : CAutoGameSystem("")
{
}

// Bin Patch format:
//==============================
// m_pSignature:    Memory signature
// m_iSize:         Size of mem sig
// 
// m_iOffset:       Patch offset
// m_bImmediate:    Immediate or referenced variable
// m_pPatch:        Patch bytes (int/float/char*)
//==============================
// Signature mask is now autogenerated. Wildcard bytes = \x2A
// FOR THE RECORD THIS IS SDK2013 BINS NOT TF2 ONES
//
// -sappho
CBinPatch g_EnginePatches[] = 
{
    #ifdef _WIN32
        #ifdef GAME_DLL
        // Server only!
        /*
            Patch:
            Prevent clients from lagging out the server by spamming a bunch of invalid *netchan->RequestFile requests
            This lags out the server by spamming messages to console (CALL ConMsg), which is resource intensive, because of course it is
        */
        // --- PART ONE ---
        //
        // Signature for FUN_101a44e0
        // 55 8b ec 81 ec 1c 01 00 00 53 56 69 75 08 2c 01 00 00 8b 9d 57
        // Unique string: "Download file '%s' %s"
        //
        // CNetChan::HandleUpload(char *, int)
        {
            AY_OBFUSCATE("\x55\x8b\xEC\x81\xEC\x1C\x01\x00\x00\x53\x56\x69\x75\x08\x2C\x01\x00\x00\x8B\xD9\x57"),
            // AY_OBFUSCATE("\x55\x8B\xEC\xA1\x2A\x2A\x2A\x2A\x81\xEC\x04\x01\x00\x00\xA8\x01"),
            21,
            0x303, // 0x167,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP NOP
        },
        // --- PART TWO THREE FOUR AND FIVE---
        //
        // offsets for the ConMsgs in this func are
        // 0xC3
        // 0x106
        // 0x12D
        // 0x1A6
        //
        // Signature for FUN_101a4f90
        // 55 8b ec 83 ec 0c 53 8b 5d 08 8b d1 89 55 f4 56 57
        // Unique string: "CreateFragmentsFromFile: '%s' doesn't"
        //
        // CNetChan::CreateFragmentsFromFile(char const*, int, unsigned int)
        {
            // AY_OBFUSCATE("\x55\x8B\xEC\x51\x56\x8B\x75\x08\x8B\xC1"),
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x0C\x53\x8B\x5D\x08\x8B\xD1\x89\x55\xF4\x56\x57"),
            17,
            0xC3,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x0C\x53\x8B\x5D\x08\x8B\xD1\x89\x55\xF4\x56\x57"),
            17,
            0x106,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x0C\x53\x8B\x5D\x08\x8B\xD1\x89\x55\xF4\x56\x57"),
            17,
            0x12D,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x0C\x53\x8B\x5D\x08\x8B\xD1\x89\x55\xF4\x56\x57"),
            17,
            0x1A6,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP NOP
        },
        #else
        // Client only!
        /*
            Patch:
            Prevent the culling of skyboxes at high FOVs
        */
        // Signature for sub_100ECF90 (branch previous2021: 0x10106EA0)
        // 55 8B EC 81 EC 54 02 00 00 8B 0D ? ? ? ?
        // Uniqueish string: R_DrawSkybox
        // 
        //
        // if ( (((v6 * *&dword_103C0274) + (v7 * *&dword_103C0278)) + (v8 * *&dword_103C027C)) >= -0.29289001 )
        // ->
        // if ( (((v6 * *&dword_103C0274) + (v7 * *&dword_103C0278)) + (v8 * *&dword_103C027C)) >= -1.0 )
        //
        // R_DrawSkyBox
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x81\xEC\x58\x02\x00\x00\x8B\x0D\x2A\x2A\x2A\x2A\x33\xD2"),
            17,
            0x278,
            PATCH_REFERENCE, // we are changing the value of a float**
            -1.0f
        },
        // Unclamp mat_picmip
        // Multiple patches are required since the new engine is comparing a pointer (current value?)
        // to the raw, non-negative values. so we just replace the values that it's comparing the pointer to.
        // 
        // Signature for sub_10184f30 (branch previous2021: 101A4B70)
        // 55 8b ec 83 ec 20 8b ?? ?? ?? ?? ?? 33 d2 53 33 db
        // \x55\x8B\xEC\x83\xEC\x20\x8B\x2A\x2A\x2A\x2A\x2A\x33\xD2\x53\x33\xDB
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x20\x8B\x2A\x2A\x2A\x2A\x2A\x33\xD2\x53\x33\xDB"),
            17,
            0x92,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x0A")
        },
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x20\x8B\x2A\x2A\x2A\x2A\x2A\x33\xD2\x53\x33\xDB"),
            17,
            0x9E,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x0A")
        },
        // rootlod callback (?) 
        // Signature for sub_100f3ea0: (branch previous2021: 0x1010dcc0)
        // 55 8B EC 83 EC 08 6A 02
        // \x55\x8B\xEC\x83\xEC\x08\x6A\x02
        {
            AY_OBFUSCATE("\x55\x8B\xEC\x83\xEC\x0C\x6A\x02\x6A\x00"),
            8,
            0x6,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x6A\x06\x6A\xF0")
        },

        // rootlod
        // Signature for sub_100F12B0: (branch previous2021: 0x101083f0)
        // 6A 02 6A 00 68 ? ? ? ? E8 ? ? ? ? 83 C4 0C C3
        {
            AY_OBFUSCATE("\x6A\x02\x6A\x00\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\xC4\x0C\xC3"),
            18,
            0x0,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x6A\x06\x6A\xF0")
        },

        // lod
        // Signature for sub_100F1290: (previous2021: 100F1E40)
        // 6A 02 6A FF 68 ? ? ? ? 
        // \x6A\x02\x6A\xFF\x68\x2A\x2A\x2A\x2A
        // new signature
        // 6a 02 6a ff 68 ?? ?? ?? ?? e8 ?? ?? ?? ?? 83 c4 0c c3
        // \x6A\x02\x6A\xFF\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\xC4\x0C\xC3
        {
            // AY_OBFUSCATE("\x6A\x02\x6A\xFF\x68\x2A\x2A\x2A\x2A"),
            AY_OBFUSCATE("\x6A\x02\x6A\xFF\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\xC4\x0C\xC3"),
            18, // 9,
            0x0,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x6A\x0A\x6A\xF0")
        }

        #endif
    #else 
    // LINUX
        #ifdef GAME_DLL
        // Server only!
        /*
            Patch:
            Prevent clients from lagging out the server by spamming a bunch of invalid *netchan->RequestFile requests
            This lags out the server by spamming messages to console (CALL ConMsg), which is resource intensive, because of course it is
        */
        // --- PART ONE ---
        //
        // Signature for _ZN8CNetChan12HandleUploadEPNS_15dataFragments_sEP18INetChannelHandler:
        // previous2021: FUN_004ee130
        // 55 89 E5 81 EC 48 01 00 00 80 3D ? ? ? ? 00
        // 
        // latest: FUN_003cc630
        // 55 89 E5 57 56 53 81 EC 1C 01 00 00 8B 75 08 0F B6 05 ?? ?? ?? ?? 84 C0
        // 
        // Unique string: "Download file '%s' %s"
        //
        // CNetChan::HandleUpload(char *, int)
        {
            // AY_OBFUSCATE("\x55\x89\xE5\x81\xEC\x48\x01\x00\x00\x80\x3D\x2A\x2A\x2A\x2A\x00"),
            AY_OBFUSCATE("\x55\x89\xE5\x57\x56\x53\x81\xEC\x1C\x01\x00\x00\x8B\x75\x08\x0F\xB6\x05\x2A\x2A\x2A\x2A\x84\xC0"),
            24, // 16,
            0x3F, // 0x60,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP
        },
        // --- PART TWO THREE FOUR AND FIVE---
        //
        // offsets for the ConMsgs in this func are
        // 1DE
        // 1B5
        // 201
        // 21D
        //
        // Signature for FUN_004f0240 (previous2021)
        // 55 89 E5 83 EC 48 89 5D F4 8B 5D 0C 89 7D FC
        // \x55\x89\xE5\x83\xEC\x48\x89\x5D\xF4\x8B\x5D\x0C\x89\x7D\xFC
        // 
        // latest: FUN_003c7e10
        // 55 89 E5 57 89 CF 56 53 89 D3 83 EC 30 89 45 D4 A1 ?? ?? ?? ?? 8D 50 04 8B 40 04
        // \x55\x89\xE5\x57\x89\xCF\x56\x53\x89\xD3\x83\xEC\x30\x89\x45\xD4\xA1\x2A\x2A\x2A\x2A\x8D\x50\x04\x8B\x40\x04
        // 
        // new offsets
        // 0x191
        // 0x1DB
        // 0x170
        // 0x1B4
        // 
        // Unique string: "CreateFragmentsFromFile: '%s' doesn't"
        //
        // CNetChan::CreateFragmentsFromFile(char const*, int, unsigned int)
        {
            AY_OBFUSCATE("\x55\x89\xE5\x57\x89\xCF\x56\x53\x89\xD3\x83\xEC\x30\x89\x45\xD4\xA1\x2A\x2A\x2A\x2A\x8D\x50\x04\x8B\x40\x04"),
            27, // 15,
            0x191,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x89\xE5\x57\x89\xCF\x56\x53\x89\xD3\x83\xEC\x30\x89\x45\xD4\xA1\x2A\x2A\x2A\x2A\x8D\x50\x04\x8B\x40\x04"),
            27, // 15,
            0x1DB,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x89\xE5\x57\x89\xCF\x56\x53\x89\xD3\x83\xEC\x30\x89\x45\xD4\xA1\x2A\x2A\x2A\x2A\x8D\x50\x04\x8B\x40\x04"),
            27, // 15,
            0x170,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP
        },
        {
            AY_OBFUSCATE("\x55\x89\xE5\x57\x89\xCF\x56\x53\x89\xD3\x83\xEC\x30\x89\x45\xD4\xA1\x2A\x2A\x2A\x2A\x8D\x50\x04\x8B\x40\x04"),
            27, // 15,
            0x1B4,
            PATCH_IMMEDIATE,
            AY_OBFUSCATE("\x90\x90\x90\x90\x90") // CALL -> NOP NOP NOP NOP NOP
        },
        #else
        // Client only!
        /*
            Patch:
            Prevent the culling of skyboxes at high FOVs
        */
        //
        // Signature for sub_464880: (latest2021)
        // 55 89 E5 57 56 53 81 EC CC 02 00 00 C7 45 C8 00 00 00 00
        //
        // Signature for FUN_002d4c10:
        // 55 66 0F EF C0 89 E5 57 56 53 81 EC 8C 02 00 00 A1 ?? ?? ?? ?? C7 85 80 FD FF FF 00 00 00 00
        // \x55\x66\x0F\xEF\xC0\x89\xE5\x57\x56\x53\x81\xEC\x8C\x02\x00\x00\xA1\x2A\x2A\x2A\x2A\xC7\x85\x80\xFD\xFF\xFF\x00\x00\x00\x00
        // 
        // Uniqueish string: R_DrawSkybox
        //
        // if ( (((v6 * *&dword_B71424) + (v5 * *&dword_B71420)) + (v7 * *&dword_B71428)) < -0.29289001 )
        // ->
        // if ( (((v6 * *&dword_B71424) + (v5 * *&dword_B71420)) + (v7 * *&dword_B71428)) < -1.0 )
        //
        // R_DrawSkyBox
        // search for raw hex "BE95F5AE" and then go to the function that references that data. should be FUN_002d4c10
        // code to replace isn't visible for the 32bit linux binary, but the MOVSS instructions match
        //
        // linux:
        // 002d4e50 f3 0f 59        MULSS    XMM2,dword ptr [DAT_0086115c]    = ??
        //          15 5c 11
        //          86 00
        // 002d4e58 f3 0f 59        MULSS    XMM1,dword ptr [DAT_0061158]     = ??
        //          0d 58 11
        //          86 00
        // 002d4e60 f3 0f 59        MULSS    XMM3,dword ptr [DAT_0061160]     = ??
        //          1d 60 11
        //          86 00
        // 002d4e68 f3 0f 10        MOVSS    XMM7,dword ptr [DAT_0066fac0]    = BE95F5AEh     <<<< HERE
        //          3d c0 fa
        //          66 00
        //
        // windows:
        // 100ed1e4 f3 0f 59        MULSS    XMM0,dword ptr [DAT_103c5d78]
        //          05 78 5d
        //          3c 10
        // 100ed1ec f3 0f 59        MULSS    XMM4,dword ptr [DAT_103c5d74]    = 3F800000h
        //          25 74 5d
        //          3c 10
        // 100ed1f4 f3 0f 59        MULSS    XMM1,dword ptr [DAT_103c5d7c]
        //          0d 7c 5d
        //          3c 10
        // 100ed1fc f3 0f 58 c4     ADDSS    XMM0,XMM4
        // 100ed200 f3 0f 58 c1     ADDSS    XMM0,XMM1
        // 100ed204 f3 0f 10        MOVSS    XMM1,dword ptr [DAT_10309280]    = BE95F5AEh     <<<< HERE
        //          0d 80 92
        //          30 10
        // 100ed20c 0f 2f c8        COMISS   XMM1,XMM0
        // 100ed20f 0f 87 51        JA       LAB_100ed666
        //          04 00 00
        {
            // AY_OBFUSCATE("\x55\x89\xE5\x57\x56\x53\x81\xEC\xCC\x02\x00\x00\xC7\x45\xC8\x00\x00\x00\x00"),
            AY_OBFUSCATE("\x55\x66\x0F\xEF\xC0\x89\xE5\x57\x56\x53\x81\xEC\x8C\x02\x00\x00\xA1\x2A\x2A\x2A\x2A\xC7\x85\x80\xFD\xFF\xFF\x00\x00\x00\x00"),
            31, // 19,
            0x25C, // 0x424,
            PATCH_REFERENCE, // we are changing the value of a float**
            -1.0f
        },
        #endif
    #endif
};


#include <fakeconvar.h>
void CBinary::PostInit()
{
    // Only run this on dedicated servers, not on clients
    #ifdef GAME_DLL
        if (engine->IsDedicatedServer())
        {
            bool didpatches = ApplyAllPatches();

            if (!didpatches)
            {
                #ifdef dbging
                    Warning("CEngineBinary::EPostInit -> Failed to apply server patches!\n");
                #else
                    Error("Failed to apply server patches!\n");
                    return;
                #endif
            }
            #ifdef dbging
            else
            {
                ConColorMsg(goodcolor, "CEngineBinary::EPostInit -> Successfully applied server patches!\n");
            }
            #endif
        }
    #else
        bool didpatches = ApplyAllPatches();

        if (!didpatches)
        {
            #ifdef dbging
                Warning("CEngineBinary::EPostInit -> Failed to apply client patches!\n");
            #else
                Error("Failed to apply client patches!\n");
                return;
            #endif
        }
        #ifdef dbging
        else
        {
            ConColorMsg(goodcolor, "CEngineBinary::EPostInit -> Successfully applied client patches!\n");
        }
        #endif



        // Fully fix the rest of mat_picmip - set in a bin patch we had earlier.
        ConVarRef mat_picmip("mat_picmip");
        ConVarRef r_rootlod("r_rootlod");
        ConVarRef r_lod("r_lod");
        if (mat_picmip.IsValid())
        {
            ConVar*     realVar = static_cast<ConVar*>(mat_picmip.GetLinkedConVar());
            FakeConVar* fakeVar = reinterpret_cast<FakeConVar*>(realVar);
            fakeVar->SetMax(10.0);
            fakeVar->SetMin(-10.0);
        }
        if (r_rootlod.IsValid())
        {
            ConVar* realVar     = static_cast<ConVar*>(r_rootlod.GetLinkedConVar());
            FakeConVar* fakeVar = reinterpret_cast<FakeConVar*>(realVar);
            fakeVar->SetMax(6.0);
            fakeVar->SetMin(-10.0);
        }
        if (r_lod.IsValid())
        {
            ConVar* realVar     = static_cast<ConVar*>(r_lod.GetLinkedConVar());
            FakeConVar* fakeVar = reinterpret_cast<FakeConVar*>(realVar);
            fakeVar->SetMax(10.0);
            fakeVar->SetMin(-10.0);
        }

    #endif

    // now run engine detours
    gCEngineDetours = new CEngineDetours;

    return;
}

bool CBinary::ApplyAllPatches()
{
    // loop thru our engine patches
    for (int i = 0; i < (sizeof(g_EnginePatches) / sizeof(*g_EnginePatches)); i++)
    {
        // if something goes wrong, bail
        if (!g_EnginePatches[i].ApplyPatch(engine_bin))
        {
            #ifdef dbging
                Warning("CEngineBinary::ApplyAllPatches -> Couldn't apply patch %i\n", i);
                continue;
            #else
                return false;
            #endif
            
        }
        else
        {
            #ifdef dbging
                ConColorMsg(goodcolor, "CEngineBinary::ApplyAllPatches -> Applied patch %i\n", i);
            #endif
        }
    }
    return true;
}

bool CBinPatch::ApplyPatch(modbin* mbin)
{
    if (!m_pPatch)
    {
        // No value provided to patch
        #ifdef dbging
            Warning("CBinPatch::ApplyPatch -> No value provided for patch\n");
        #endif

        return false;
    }


    void* addr = (void*)memy::FindPattern(
        mbin->addr,
        mbin->size,
        m_pSignature,
        m_iSize,
        m_iOffset
    );

    if (addr)
    {
        void* pMemory = m_bImmediate ? (uintptr_t*)addr : *reinterpret_cast<uintptr_t**>(addr);

        // Memory is write-protected so it needs to be lifted before the patch is applied
        int prot = NULL;
        if (memy::SetMemoryProtection(pMemory, m_iPatchLength, MEM_READ | MEM_WRITE | MEM_EXEC, &prot))
        {
            V_memcpy(pMemory, m_pPatch.get(), m_iPatchLength);

            int _ = 0;
#ifdef _WIN32
            memy::SetMemoryProtection(pMemory, m_iPatchLength, prot, &_);
#else
            memy::SetMemoryProtection(pMemory, m_iPatchLength, MEM_READ | MEM_EXEC, &_);
#endif
            // Success!
            return true;
        }
        else
        {
            #ifdef dbging
                Warning("CBinPatch::ApplyPatch -> Couldn't override mem protection for pattern %s, size %i, offs %i\n", m_pSignature, m_iSize, m_iOffset);
            #endif

            return false;
        }
    }
    else
    {
        // Couldn't find sig
        #ifdef dbging
            Warning("CBinPatch::ApplyPatch -> Couldn't find sig for pattern %s, size %i, offs %i\n", m_pSignature, m_iSize, m_iOffset);
        #endif
        return false;
    }
}

CBinPatch::CBinPatch(char* signature, size_t sigsize, size_t offset, bool immediate)
{
    m_pSignature    = signature;
    m_iSize         = sigsize,
    m_iOffset       = offset;
    m_bImmediate    = immediate;
    m_pPatch        = nullptr;
    m_iPatchLength  = 0;
}

CBinPatch::~CBinPatch()
{
}


// Converting numeric types into bytes
CBinPatch:: CBinPatch(char* signature, size_t sigsize, size_t offset, bool immediate, int value)
    :       CBinPatch(signature, sigsize, offset, immediate)
{
    m_iPatchLength = sizeof(value);
    m_pPatch = std::make_unique<char>( m_iPatchLength );
    memcpy(m_pPatch.get(), &value, m_iPatchLength);
}

CBinPatch:: CBinPatch(char* signature, size_t sigsize, size_t offset, bool immediate, float value)
    :       CBinPatch(signature, sigsize, offset, immediate)
{
    m_iPatchLength = sizeof(value);
    m_pPatch = std::make_unique<char>(m_iPatchLength);
    memcpy(m_pPatch.get(), &value, m_iPatchLength);
}


// BUGBUG!!!!
// SIZEOF ISN'T CORRECT IF YOU HAVE NULL BYTES IN THE PATCH??
CBinPatch:: CBinPatch(char* signature, size_t sigsize, size_t offset, bool immediate, char* bytes)
    :       CBinPatch(signature, sigsize, offset, immediate)
{
    m_iPatchLength = strlen(bytes);
    m_pPatch = std::make_unique<char>(m_iPatchLength);
    memcpy(m_pPatch.get(), bytes, m_iPatchLength);

    #ifdef dbging
        char hexstr[128] = {};
        V_binarytohex
        (
            reinterpret_cast<const byte*>(signature),
            (sigsize * 2),
            hexstr,
            (sigsize * 2)
        );

        Warning("patchlen %s = %i / %i \n", hexstr, sizeof(bytes), strlen(bytes));
    #endif
}
#endif
